#!/usr/bin/python3

import os, sys
import argparse
import xml.etree.ElementTree as ET
from xml.dom import minidom
import pyastyle


#---------------------------------------------------------------
# class State
#---------------------------------------------------------------
class State:
    def __init__(self):
        self.sid = ''
        self.parent = []
        self.isInitial = False
        self.internal = []          # (type, event, code)
        self.external = []          # (type, event, target)
        self.entry = (False, '')    # (True/False, code)
        self.exit  = (False, '')    # (True/False, code)


#---------------------------------------------------------------
# class SMCode
#---------------------------------------------------------------
class SMCode:
    def __init__(self):
        self.includes = []
        self.states = []
        self.eventDict = dict()
        self.initialDict = dict()

    def printStates(self):
        for state in self.states:
            print(state.sid, state.internal, state.external)

    def generateCode(self):
        impl = ''
        api = ''
        api_sm_include = ''
        pyapi = ''

        pyapi += "# Note: This file is an autogenerated API of "+ self.states[0].sid +" statemachine\n"
        pyapi += "# and should not be edited manually.\n\n"

        pyapi = '#!/usr/bin/python3'
        pyapi += '\n\n\n'
        pyapi += 'class PySmAPI():'
        pyapi += '\n\n'

        num = 1
        for event in self.eventDict.keys():
            nmeStr = 4*' ' + event
            pyapi += nmeStr + ' '*(40-len(nmeStr)) + ' = ' + str(num) + '\n'
            num += 1

        pyapi += '\n\n'
        pyapi += 4*' ' + 'def __init__(self):'
        pyapi += '\n'
        pyapi += 8*' ' + 'return'
        pyapi += '\n'


        impl += "// Note: This file is an autogenerated API/Implementation of statemachine\n"
        impl += "// and should only be edited (if needed) within the START/END tags.\n"
        impl += "// Adding an event or state is not allowed as it will break the consistency\n"
        impl += "// with statemachine diagram.\n\n\n"


        impl += "#include "+'"SM'+self.states[0].sid+'.h"\n\n'

        impl += "// @ACSTAG:INCLUDES:UCODE:START\n"
        for include in self.includes:
            if 'ACStates.h' in include:
                api_sm_include = include
            else:
                impl += "#include "+ include +'\n'
        impl += "// @ACSTAG:INCLUDES:UCODE:END\n\n"


        impl += 'ScheduleEventPtr_t scheduleEvent;\n'


        impl += 'enum EVENTS\n'
        impl +='{\n'
        impl += 4*' '+'EV_DEFAULT_ENTRY'+8*' '+'= EV_DEFAULT_ENTRY_LIB,\n'
        for event in self.eventDict.keys():
            impl += 4*' '+event+',\n'
        impl += '};\n\n'


        sids = []
        for state in self.states:
            sids.append(state.sid)
        impl += 'State_t ' + ', '.join(sids) + ';\n'
        impl += 'StateMachine_t sm;\n\n\n\n\n'


        for state in self.states:
            sid = state.sid
            impl += '// '+sid + '\n'
            impl += 'EventState_t '+sid+'_entry(Event_t ev)\n'
            impl += '{\n'
            if state.entry[0] == True:
                impl += "// @ACSTAG:ENTRY:"+sid+":UCODE:START\n"
                # Script node exits but is blank. So insert a newline here.
                if None == state.entry[1]:
                    impl += '\n'
                else:
                    impl += 4*' '+state.entry[1].replace('\n', '\n'+4*' ').strip() + '\n'
                impl += "// @ACSTAG:ENTRY:"+sid+":UCODE:END\n"
            impl += 4*' '+'return EVENT_HANDLED;\n'
            impl += '}\n'

            impl += 'EventState_t '+sid+'_inprogress(Event_t ev)\n'
            impl += '{\n'

            for inttran in state.internal:
                impl += 4*' '+'if (ev.eventId=='+inttran[1]+')\n'
                impl += 4*' '+'{\n'
                code = inttran[2]
                impl += "// @ACSTAG:INTTRAN:"+sid+":"+inttran[1]+":UCODE:START\n"
                impl += 8*' '+code.replace('\n', '\n'+8*' ').strip() +'\n'
                impl += "// @ACSTAG:INTTRAN:"+sid+":"+inttran[1]+":UCODE:END\n"
                impl += 8*' '+'return EVENT_HANDLED;\n'
                impl += 4*' '+'}\n'

            impl += 4*' '+'return EVENT_NOT_HANDLED;\n'
            impl += '}\n'

            impl += 'EventState_t '+sid+'_exit(Event_t ev)\n'
            impl += '{\n'
            if state.exit[0] == True:
                impl += "// @ACSTAG:EXIT:"+sid+":UCODE:START\n"
                # Script node exits but is blank. So insert a newline here.
                if None == state.exit[1]:
                    impl += '\n'
                else:
                    impl += 4*' '+state.exit[1].replace('\n', '\n'+4*' ').strip() + '\n'
                impl += "// @ACSTAG:EXIT:"+sid+":UCODE:END\n"
            impl += 4*' '+'return EVENT_HANDLED;\n'
            impl += '}\n\n\n\n\n'


        impl += 'void initSM_' + self.states[0].sid+'()\n'
        impl += '{\n'
        state_count = 0
        for state in self.states:
            if state_count==0:
                impl += 4*' '+'prepareState(&sm, &'+state.sid+', '+state.sid+'_entry, '+state.sid+'_inprogress, '+state.sid+'_exit, NULL);\n'
            else:
                impl += 4*' '+'prepareState(&sm, &'+state.sid+', '+state.sid+'_entry, '+state.sid+'_inprogress, '+state.sid+'_exit, &'+state.parent.sid+');\n'
            state_count += 1
        impl += '\n'


        for state in self.states:
            for exttran in state.external:
                impl += 4*' '+'addTransition(&'+state.sid+', '+exttran[1]+', &'+exttran[2]+');\n'
        impl += '\n'


        for state in self.states:
            if state.isInitial==True:
                impl += 4*' '+'setInitialState(&'+state.sid+');\n'
        impl += '}\n\n'


        impl += 'void installSM_' + self.states[0].sid+'ScheduleEventHandle(ScheduleEventPtr_t ptr)\n'
        impl += '{\n'
        impl += 4*' '+'scheduleEvent = ptr;\n'
        impl += '}\n\n'

        impl += 'void startSM_' + self.states[0].sid+'()\n'
        impl += '{\n'
        impl += 4*' '+'startMachine(&sm);\n'
        impl += '}\n\n'

        impl += 'void triggerSM_' + self.states[0].sid+'Event(Event_t ev)\n'
        impl += '{\n'
        impl += 4*' '+'triggerEvent(&sm, ev);\n'
        impl += '}\n'



        api += "// Note: This file is an autogenerated API of "+ self.states[0].sid +" statemachine\n"
        api += "// and should not be edited manually.\n\n"

        api += "#ifndef SM_"+self.states[0].sid.upper()+"_H\n"
        api += "#define SM_"+self.states[0].sid.upper()+"_H\n"


        if api_sm_include != '':
            api += "#include "+ api_sm_include + "\n"


        api += 4 * '\n'
        api += "// Install callback handle to schedule a delayed event.\n"
        api += 'typedef void (*ScheduleEventPtr_t)(Event_t);\n'
        api += 'void installSM_' + self.states[0].sid+'ScheduleEventHandle(ScheduleEventPtr_t ptr);\n'

        api += 2 * '\n'
        api += "// Initilizes statemachine.\n"
        api += 'void initSM_' + self.states[0].sid+'();\n'

        api += 2 * '\n'
        api += "// Starts statemachine.\n"
        api += 'void startSM_' + self.states[0].sid+'();\n'

        api += 2 * '\n'
        api += "// Trigger event in statemachine.\n"
        api += 'void triggerSM_' + self.states[0].sid+'Event(Event_t ev);\n'

        api += 4 * '\n'
        api += "#endif    // " + "SM_"+self.states[0].sid.upper()+"_H\n"


        impl = pyastyle.format(impl, '--style=allman --indent=spaces=4')
        api = pyastyle.format(api, '--style=allman --indent=spaces=4')

        print("API:")
        print(api)
        print("IMPLEMENTATION:")
        print(impl)
        print("PYAPI:")
        print(pyapi)

        return (impl, api, pyapi)


#---------------------------------------------------------------
# ParseMeta
#---------------------------------------------------------------
def ParseMeta(root_state, smcode):
    for node in root_state:
        if 'metadata' in node.tag:
            for meta in node:
                if 'include' in meta.tag:
                    smcode.includes = meta.text.split('\n')


#---------------------------------------------------------------
# ParseState
#---------------------------------------------------------------
def ParseState(curr_state, parent, smcode):

    states = []
    internals = []
    externals = []

    # Add a new state.
    new_state = State()
    smcode.states.append(new_state)

    new_state.sid = curr_state.attrib['id']
    new_state.parent = parent

    # Check if this state is marked as initial by its parent.
    if new_state.sid in smcode.initialDict.keys():
        new_state.isInitial = True


    # Check if this state has a child marked as initial for this state.
    if 'initial' in curr_state.attrib:
        smcode.initialDict[curr_state.attrib['initial']] = 1

    # Walk through all states under this state.
    for node in curr_state:
        if 'state' in node.tag:
            states.append(node)

    # Sort states by ids.
    states = sorted(states, key = lambda i: i.attrib['id'])
    for node in states:
        # Make a recursive call.
        ParseState(node, new_state, smcode)


    # Internal transitions.
    for node in curr_state:
        if 'transition' in node.tag and node.attrib['type'] == 'internal':
            code = ""
            for script in node:
                if 'script' in script.tag:
                    code = script.text
            internals.append( (node.attrib['type'], node.attrib['event'], code) )

    # External transitions.
    for node in curr_state:
        if 'transition' in node.tag and node.attrib['type'] == 'external':
            externals.append( (node.attrib['type'], node.attrib['event'], node.attrib['target']) )

    # Sort transitions by events.
    internals.sort(key = lambda x: x[1])
    externals.sort(key = lambda x: x[1])

    # Create transitions and add to the current state.
    for internal in internals:
        new_state.internal.append((internal[0], internal[1], internal[2]))
        smcode.eventDict[internal[1]] = 1

    for external in externals:
        new_state.external.append((external[0], external[1], external[2]))
        smcode.eventDict[external[1]] = 1

    # Entry/Exit
    for node in curr_state:
        if 'onentry' in node.tag:
            for script in node:
                if 'script' in script.tag:
                    new_state.entry = (True, script.text)
        if 'onexit' in node.tag:
            for script in node:
                if 'script' in script.tag:
                    new_state.exit = (True, script.text)

    return


#---------------------------------------------------------------
# ParseScxml
#---------------------------------------------------------------
def ParseScxml(input_file):

    tree = ET.parse(input_file)
    root = tree.getroot()

    statemachine = None
    for child in root:
        statemachine = child

    smcode = SMCode()
    ParseMeta(statemachine, smcode)
    ParseState(statemachine, None, smcode)
    code = smcode.generateCode()

    return (statemachine.attrib['id'], code[0], code[1], code[2])



#---------------------------------------------------------------
# ParseCode
#---------------------------------------------------------------
def ParseCode(scxml_file, src_file):

    ET.register_namespace('', "http://www.w3.org/2005/07/scxml")
    ET.register_namespace('qt', "http://www.qt.io/2015/02/scxml-ext")

    src = ''
    with open(src_file) as f:
        src = f.readlines()


    tree = ET.parse(scxml_file)
    root = tree.getroot()


    all_states = []
    nodes = []
    nodes.append(root)

    content = ''

    while len(nodes) > 0:
        curr_node = nodes[0]
        nodes = nodes[1:]

        read = False
        script_node = None

        if 'state' in curr_node.tag:

            for line in src:

                # Parsing entry code.
                if line == '// @ACSTAG:ENTRY:' + curr_node.attrib['id'] + ':UCODE:START\n':
                    read = True
                    # Find the script tag in this state for entry.
                    for node in curr_node:
                        if 'onentry' in node.tag:
                            for sn in node:
                                if 'script' in sn.tag:
                                    script_node = sn
                                    script_node.text = ''

                elif line == '// @ACSTAG:ENTRY:' + curr_node.attrib['id'] + ':UCODE:END\n':
                   if script_node != None:
                       script_node.text = pyastyle.format(script_node.text, '--style=allman --indent=spaces=4')
                       script_node = None
                   read = False


                # Parsing exit code.
                elif line == '// @ACSTAG:EXIT:' + curr_node.attrib['id'] + ':UCODE:START\n':
                    read = True
                    # Find the script tag in this state for exit.
                    for node in curr_node:
                        if 'onexit' in node.tag:
                            for sn in node:
                                if 'script' in sn.tag:
                                    script_node = sn
                                    script_node.text = ''

                elif line == '// @ACSTAG:EXIT:' + curr_node.attrib['id'] + ':UCODE:END\n':
                    if script_node != None:
                       script_node.text = pyastyle.format(script_node.text, '--style=allman --indent=spaces=4')
                       script_node = None
                    read = False


                # Parsing internal transition code.
                elif ('// @ACSTAG:INTTRAN:' + curr_node.attrib['id'] + ':') in line and (':UCODE:START\n') in line:
                    read = True
                    internal = line.replace('// @ACSTAG:INTTRAN:' + curr_node.attrib['id'] + ':', '').replace(':UCODE:START\n', '')
                    # Find the script tag in this state for this particular internal transition.
                    for node in curr_node:
                        if 'transition' in node.tag and node.attrib['type'] == 'internal' and node.attrib['event'] == internal:
                            for sn in node:
                                if 'script' in sn.tag:
                                    script_node = sn
                                    script_node.text = ''

                elif ('// @ACSTAG:INTTRAN:' + curr_node.attrib['id'] + ':') in line and (':UCODE:END\n') in line:
                   if script_node != None:
                       script_node.text = pyastyle.format(script_node.text, '--style=allman --indent=spaces=4')
                       script_node = None
                   read = False



                elif read == True:
                    if script_node != None:
                        script_node.text += line

        for node in curr_node:
            nodes.append(node)

    scxml = ET.tostring(root, encoding='utf8').decode('utf8')
    print(scxml)
    return scxml



#---------------------------------------------------------------
# Main
#---------------------------------------------------------------
if __name__=="__main__":

    # Prepare argument parser.
    parser = argparse.ArgumentParser()

    parser.add_argument('--scxml',
                        action='store',
                        default='',
                        help='specify file saved by qt designer with scxml extension')

    parser.add_argument('--code',
                        action='store',
                        default='',
                        help='specify c source file generated before')

    parser.add_argument('-g',
                        '--generate-code',
                        action='store_true',
                        help='generate source *.c *.h files')

    parser.add_argument('-u',
                        '--update-scxml',
                        action='store_true',
                        help='update scxml from *.c file')


    arguments = parser.parse_args()


    if arguments.update_scxml == True:
        if arguments.scxml == '':
            print("Please specify scxml file")
            sys.exit(0)
        if arguments.code == '':
            print("Please specify c source file")
            sys.exit(0)
        scxml = ParseCode(arguments.scxml, arguments.code)
        with open(arguments.scxml, "w") as wf:
            wf.writelines(scxml)
        sys.exit(0)



    if arguments.scxml == '':
        print("Please specify scxml file")
        sys.exit(0)

    code = ParseScxml(arguments.scxml)

    if arguments.generate_code == True:
        with open('SM'+code[0]+'.c', 'w') as filehandle:
            filehandle.writelines(code[1])
        with open('SM'+code[0]+'.h', 'w') as filehandle:
            filehandle.writelines(code[2])
        with open('SM'+code[0]+'.py', 'w') as filehandle:
            filehandle.writelines(code[3])
    else:
        for line in code[1]:
            print(line)
        print(5 * '\n')
        for line in code[2]:
            print(line)
        print(5 * '\n')
        for line in code[3]:
            print(line)
